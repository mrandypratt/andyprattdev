# Version 2: Multi-Device MVP

## Tools Used (In addition to V1):
- TypeScript
- Node.js
- Express
- Socket.io
- PM2
- Async/Await

## Product Vision & Goals
The vision of the product at Version 2 was to allow uses to play the game with friends online on separate devices. This would allow in-person or fully remote gameplay. From talking to users about the game, it seemed that being able to experience the reactions of other players was very important, so I decided to continue to optimize for people playing the game with one another while either in-person or remote alongside a video call.

The goal for V2 was to craft a multi-device experience that would allow users to log onto the website on different devices, connect online, and play the game.

FYI - Version 2 was a large number of changes being bundled together, so this is a more linear summary of all these changes.

## Identifying Problems
Enabling online play was the premier technical challenge, and had a number of ripple-effects. The shift from a self-contained game engine in the browser, to enabling state updates across multiple clients entailed:

- Re-Mapping the the application flow.
- Creating new views to represent the new flow and user classes.
- Tracking and identifying each client within and across connections.
- Allowing users a way to organize and connect in an online game.
- Tracking Game State for each client and updating across all clients in the same game.
- Updating the Data Structures/Algorithms.
- Creating a more complete Gameplay Experience to keep track of Round and Game Winners.
- Improving the UX and UI along the way to be more responsive and clean.

Finally, some of my content was unsavory, so I also wanted an option for more "safe-for-work" content.

## Understanding the Problems
Similar to V1, I started by tracking breaking down the logical steps of the game into pseudo-code.  I found there were two distinct phases of the application flow:

### Creating Game: Host and Guest Path
- User visits Home Page as one of the following:
  - Host: User looking to Start a Game
    - Host enters name and selects card deck
    - Lobby is created
    - Host invites friends to join the lobby
    - When friends arrive, user may start gameplay 
  - Guest: User looking to Join a Game
    - Guest enters name and finds and joins their desired host's lobby
    - Guest enters gameplay when host starts game
  - Info: User wants to Learn about the Game
    - User reads info and returns home

### Gameplay
- Game Begins 
  - Round Started
    - Cards are dealt to all game participants & Prompt Card is drawn.
    - One participant is designated as judge.
    - All non-judge players will select a Response Card from their hand.
      - If all players have not selected, the player will be waiting.
      - The Judge Will be waiting.
    - Judge Player will select the Winner
      - Non-judge players will be waiting
    - Round or Game Winner is declared
      - Player's score is incremented
      - Winning Cards and Players are displayed
      - Option to play new round/game offered
- Loop

### Additional Considerations
For a plesant gameplay experience, the app will need to handle additional functionality:

- User refreshes connection or leaves site should not abandon game or lose state/view data.
- Numer of players should be dynamic.
- Game State needs to centralized and updated instantly across clients.
- A user should be able to leave the lobby or end a game.

Now with some pseudo-code and requirements, I could start putting together visuals to represent the states and actions.

## Mapping out the Experience


## Engineering the Solution

### Scalability of Code
Since I was going to be moving things around a lot, I knew one thing I wanted to do was implement TypeScript to leverage type-safety and linting.  It made sense to make this migration first before adding additional features.

### Back-End
With a networked game, it was time to create a server.

- Node.js with Express: Enabled the setup of an HTTP server with many options for easy integration with other technologies thanks to Express's flexibility.
-	Socket.io: Added to enable bi-directional socket communication between all clients and server.  Out of the box, Socket.io handles custom events from clients and makes updating across multiple users seamless using Pub/Sub events architecture.
-	Session Management: I needed to map the socket data from incoming connections to game/client state data on the server.  Socket ID’s change with each connection, so a persistent ID was needed to reference the user’s session in order to restore their most recent view or application/game state.  For this, I decided to create my own Session Store for simplicity.
-	Game State: Since multiple games can be played now at once, they had to be stored and accessible by all appropriate clients.  Created a Game Store in memory both to avoid additional Database complexity and because I only needed semi-persistence (memory to last through the game, but not after a game is finished). The tradeoff for this decision, clearly, is scalability.

### UI
-	I wanted to ensure that sifting through cards and selecting cards was clean. 
-	Creating Dialogue boxes that were clear and easy to understand
-	Adding icons and styling to waiting pages
-	Adding a robust Results page with fun icons

### UX
UX: The addition of networked gameplay added some additional complexity to the user journeys.  I divided the experience into two phases and defined 5 different user states across the two phases as outlined below:

1.	Phase 1: Setup
a.	New Users: Want to know what they can do on the app.
b.	Hosts: Want to create a Game.
c.	Guests: Want to join a Game.
2.	Phase 2: Gameplay
a.	Players: Play a card with the chance of being selected as winner by judge.
b.	Judge: Selects winner based on cards played. 

With the increased number of types of users and the spreading across multiple clients, it became even more important to remind the user at various stages of what is happening (i.e. “who is the judge?”, “who is winning?”, “why is there a delay?”, etc.).  The mockup below shows how these paths and roles were divided in the wire-frame as well as the waiting screens added to remind users of what is happening in the game while they are waiting for other players.

Exiting:  With sessions intact, I created a way for users to leave a lobby or game so they were not perpetually part of an inactive game.

### Data Structures/Algorithms
Session Store
Game Store

### Hosting/Deployment
-	AWS EC2 for Production. I had to enable CORS and set up the development server as well as production server.  Set up PM2 to run production server.
- Production Scripts

## Finished State
